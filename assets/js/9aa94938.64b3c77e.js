"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[65339],{34483:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>t,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"docs/developer-resources/best-practices/rate-limiting","title":"Rate Limiting","description":"Overview","source":"@site/docs/docs/developer-resources/best-practices/rate-limiting.md","sourceDirName":"docs/developer-resources/best-practices","slug":"/developer-resources/rate-limiting","permalink":"/docs/developer-resources/rate-limiting","draft":false,"unlisted":false,"editUrl":"https://github.com/PalisadoesFoundation/talawa-api/edit/develop/docs/docs/docs/developer-resources/best-practices/rate-limiting.md","tags":[],"version":"current","sidebarPosition":50,"frontMatter":{"id":"rate-limiting","title":"Rate Limiting","slug":"/developer-resources/rate-limiting","sidebar_position":50},"sidebar":"tutorialSidebar","previous":{"title":"GraphQL Filters & Pagination","permalink":"/docs/developer-resources/graphql-filtering"},"next":{"title":"Performance Monitoring","permalink":"/docs/developer-resources/performance-monitoring"}}');var r=n(86070),l=n(55288);const t={id:"rate-limiting",title:"Rate Limiting",slug:"/developer-resources/rate-limiting",sidebar_position:50},a="Rate Limiting in GraphQL API",d={},o=[{value:"Overview",id:"overview",level:2},{value:"Rate Limiting Levels",id:"rate-limiting-levels",level:2},{value:"1. Web Server Level (Global Rate Limiting)",id:"1-web-server-level-global-rate-limiting",level:3},{value:"2. API Level (User-Specific Rate Limiting)",id:"2-api-level-user-specific-rate-limiting",level:3},{value:"Problems with Traditional HTTP Rate Limiting",id:"problems-with-traditional-http-rate-limiting",level:2},{value:"Query Cost Calculation",id:"query-cost-calculation",level:2},{value:"Methodology",id:"methodology",level:3},{value:"Why Pre-Execution Phase?",id:"why-pre-execution-phase",level:3},{value:"GraphQL Request Lifecycle",id:"graphql-request-lifecycle",level:2},{value:"User Identification for Rate Limiting",id:"user-identification-for-rate-limiting",level:2},{value:"Rate Limiting Using the Leaky Bucket Algorithm",id:"rate-limiting-using-the-leaky-bucket-algorithm",level:2},{value:"Implementation Details",id:"implementation-details",level:3},{value:"How Cost is Deducted and Refilled",id:"how-cost-is-deducted-and-refilled",level:3},{value:"Error Handling",id:"error-handling",level:3},{value:"Environment Variables for Query Cost Configuration",id:"environment-variables-for-query-cost-configuration",level:2},{value:"Example Queries",id:"example-queries",level:2},{value:"Simple Query",id:"simple-query",level:3},{value:"Nested Query",id:"nested-query",level:3},{value:"Relay-Based Nested Query",id:"relay-based-nested-query",level:3},{value:"Simple Mutation",id:"simple-mutation",level:3},{value:"References",id:"references",level:2}];function c(e){const i={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(i.header,{children:(0,r.jsx)(i.h1,{id:"rate-limiting-in-graphql-api",children:"Rate Limiting in GraphQL API"})}),"\n",(0,r.jsx)(i.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsxs)(i.p,{children:["This section outlines the approach used to calculate query costs and enforce rate limits in our GraphQL API. We leverage the ",(0,r.jsx)(i.strong,{children:"Pothos Complexity Plugin"})," to assign complexity values to each field and use the ",(0,r.jsx)(i.strong,{children:"Leaky Bucket Algorithm"})," for rate limiting."]}),"\n",(0,r.jsx)(i.h2,{id:"rate-limiting-levels",children:"Rate Limiting Levels"}),"\n",(0,r.jsx)(i.p,{children:"Rate limiting is implemented at two broad levels:"}),"\n",(0,r.jsx)(i.h3,{id:"1-web-server-level-global-rate-limiting",children:"1. Web Server Level (Global Rate Limiting)"}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.strong,{children:"Purpose:"})}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Focuses on total incoming requests from the client."}),"\n",(0,r.jsx)(i.li,{children:"Helps prevent abuse, ensures fair usage, and protects the server from being overwhelmed by excessive requests."}),"\n",(0,r.jsx)(i.li,{children:"Prevents DDoS attacks and ensures stable server performance."}),"\n"]}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.strong,{children:"Implementation:"})}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Implemented using web server software or middleware."}),"\n",(0,r.jsx)(i.li,{children:"The number of total requests is calculated based on server capacity, database capacity, and other backend resources."}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"2-api-level-user-specific-rate-limiting",children:"2. API Level (User-Specific Rate Limiting)"}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.strong,{children:"Purpose:"})}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Ensures that no single user monopolizes resources."}),"\n",(0,r.jsx)(i.li,{children:"Particularly useful for GraphQL APIs where queries have varying complexities and resource intensities."}),"\n"]}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.strong,{children:"Implementation:"})}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Each query\u2019s cost is calculated based on the complexity of the requested data and nesting depth."}),"\n",(0,r.jsx)(i.li,{children:"If a query\u2019s cost exceeds the user\u2019s quota, it is denied."}),"\n",(0,r.jsxs)(i.li,{children:["The user\u2019s quota refills at a specific rate using the ",(0,r.jsx)(i.strong,{children:"Leaky Bucket Algorithm"}),"."]}),"\n",(0,r.jsx)(i.li,{children:"User tracking is done via IP addresses."}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"problems-with-traditional-http-rate-limiting",children:"Problems with Traditional HTTP Rate Limiting"}),"\n",(0,r.jsx)(i.p,{children:"While traditional HTTP rate limiting is effective for limiting the number of requests from a client, it has several limitations:"}),"\n",(0,r.jsxs)(i.ol,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Uniform Request Cost Assumption"})," \u2013 All requests are treated equally, even though some queries consume significantly more resources than others."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Lack of Query Complexity Awareness"})," \u2013 HTTP rate limiting does not account for query depth or computational cost, leading to inefficient resource allocation."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Ineffective Against Costly Queries"})," \u2013 Users can send fewer but highly complex queries that still overwhelm the system."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Fixed Request Limits"})," \u2013 Simple request-count-based limiting does not accommodate dynamic workloads or API-specific constraints."]}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"query-cost-calculation",children:"Query Cost Calculation"}),"\n",(0,r.jsx)(i.h3,{id:"methodology",children:"Methodology"}),"\n",(0,r.jsxs)(i.ol,{children:["\n",(0,r.jsx)(i.li,{children:"Explicitly assign a complexity value to each GraphQL field."}),"\n",(0,r.jsx)(i.li,{children:"Scalar fields use a default cost assigned in the plugin configuration."}),"\n",(0,r.jsx)(i.li,{children:"Object and list fields have assigned complexity costs, with additional costs for mutations."}),"\n",(0,r.jsxs)(i.li,{children:["Total query complexity is computed ",(0,r.jsx)(i.strong,{children:"before execution"})," to determine the cost."]}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"why-pre-execution-phase",children:"Why Pre-Execution Phase?"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"At this phase, the query syntax is already validated and exists in the GraphQL schema."}),"\n",(0,r.jsx)(i.li,{children:"Complexity can be safely computed without processing invalid queries."}),"\n",(0,r.jsx)(i.li,{children:"If the query\u2019s cost exceeds the user's quota, an error is thrown before execution."}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"graphql-request-lifecycle",children:"GraphQL Request Lifecycle"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{children:"Incoming GraphQL Request\n  \u2502\n  \u2514\u2500\u25b6 Routing\n           \u2502\n  errors \u25c0\u2500\u2534\u2500\u25b6 preParsing Hook\n                  \u2502\n         errors \u25c0\u2500\u2534\u2500\u25b6 Parsing\n                        \u2502\n               errors \u25c0\u2500\u2534\u2500\u25b6 preValidation Hook\n                               \u2502\n                      errors \u25c0\u2500\u2534\u2500\u25b6 Validation\n                                     \u2502\n                            errors \u25c0\u2500\u2534\u2500\u25b6 preExecution Hook\n                                            \u2502\n                                   errors \u25c0\u2500\u2534\u2500\u25b6 Execution\n                                                  \u2502\n                                         errors \u25c0\u2500\u2534\u2500\u25b6 Resolution\n                                                        \u2502\n                                                        \u2514\u2500\u25b6 onResolution Hook\n"})}),"\n",(0,r.jsx)(i.h2,{id:"user-identification-for-rate-limiting",children:"User Identification for Rate Limiting"}),"\n",(0,r.jsx)(i.p,{children:"To enforce rate limits, we track user-specific quotas in Redis:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Authenticated Users:"})," Identified using a combination of IP address and User ID.","\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:["Redis key: ",(0,r.jsx)(i.code,{children:"rate-limit:user:ip"})]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Unauthenticated Users:"})," Identified using only the IP address.","\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:["Redis key: ",(0,r.jsx)(i.code,{children:"rate-limit:ip"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"rate-limiting-using-the-leaky-bucket-algorithm",children:"Rate Limiting Using the Leaky Bucket Algorithm"}),"\n",(0,r.jsx)(i.h3,{id:"implementation-details",children:"Implementation Details"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:["The ",(0,r.jsx)(i.strong,{children:"Leaky Bucket Algorithm"})," controls query execution rate."]}),"\n",(0,r.jsx)(i.li,{children:"The bucket size and leak rate are configurable."}),"\n",(0,r.jsx)(i.li,{children:"Each query's cost is deducted from the user\u2019s available quota."}),"\n",(0,r.jsx)(i.li,{children:"The quota refills over time to ensure fair resource allocation."}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"how-cost-is-deducted-and-refilled",children:"How Cost is Deducted and Refilled"}),"\n",(0,r.jsxs)(i.ol,{children:["\n",(0,r.jsxs)(i.li,{children:["\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.strong,{children:"Deduction Process"})}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Each time a user makes a GraphQL request, the total cost of the query is calculated."}),"\n",(0,r.jsx)(i.li,{children:"If the cost does not exceed the available quota, it is deducted from the user\u2019s remaining quota."}),"\n",(0,r.jsxs)(i.li,{children:["If the cost ",(0,r.jsx)(i.strong,{children:"exceeds the available quota"}),", the request is denied with an error."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(i.li,{children:["\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.strong,{children:"Refilling Process"})}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:["The quota refills gradually over time, following the ",(0,r.jsx)(i.strong,{children:"Leaky Bucket Algorithm"}),"."]}),"\n",(0,r.jsx)(i.li,{children:"The refill rate is predefined (e.g., 10 points per second)."}),"\n",(0,r.jsx)(i.li,{children:"This ensures that users can send continuous requests at a controlled rate rather than consuming the entire quota at once."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(i.li,{children:["\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.strong,{children:"Example of Quota Behavior"})}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:["Assume a user has a quota of ",(0,r.jsx)(i.strong,{children:"50 points"}),"."]}),"\n",(0,r.jsxs)(i.li,{children:["The user sends a query with a cost of ",(0,r.jsx)(i.strong,{children:"20 points"})," \u2192 Remaining quota = ",(0,r.jsx)(i.strong,{children:"30"}),"."]}),"\n",(0,r.jsxs)(i.li,{children:["The user sends another query with a cost of ",(0,r.jsx)(i.strong,{children:"40 points"})," \u2192 Request ",(0,r.jsx)(i.strong,{children:"denied"})," (exceeds quota)."]}),"\n",(0,r.jsxs)(i.li,{children:["After 5 seconds (with a refill rate of 10 points/sec), the quota is restored to ",(0,r.jsx)(i.strong,{children:"50 points"}),", allowing further requests."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"error-handling",children:"Error Handling"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"If the query cost exceeds the available quota, an error is returned."}),"\n",(0,r.jsx)(i.li,{children:"Users can retry requests once their quota refills over time."}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"environment-variables-for-query-cost-configuration",children:"Environment Variables for Query Cost Configuration"}),"\n",(0,r.jsxs)(i.table,{children:[(0,r.jsx)(i.thead,{children:(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.th,{children:"Environment Variable"}),(0,r.jsx)(i.th,{children:"Description"})]})}),(0,r.jsxs)(i.tbody,{children:[(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:(0,r.jsx)(i.code,{children:"API_GRAPHQL_SCALAR_FIELD_COST"})}),(0,r.jsxs)(i.td,{children:["Cost assigned to scalar fields such as ",(0,r.jsx)(i.code,{children:"id"}),", ",(0,r.jsx)(i.code,{children:"name"}),", etc."]})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:(0,r.jsx)(i.code,{children:"API_GRAPHQL_SCALAR_RESOLVER_FIELD_COST"})}),(0,r.jsx)(i.td,{children:"Cost for scalar fields that require resolver logic."})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:(0,r.jsx)(i.code,{children:"API_GRAPHQL_OBJECT_FIELD_COST"})}),(0,r.jsx)(i.td,{children:"Cost for object fields that return nested objects."})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:(0,r.jsx)(i.code,{children:"API_GRAPHQL_LIST_FIELD_COST"})}),(0,r.jsx)(i.td,{children:"Cost for list fields that return an array of objects."})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:(0,r.jsx)(i.code,{children:"API_GRAPHQL_NON_PAGINATED_LIST_FIELD_COST"})}),(0,r.jsx)(i.td,{children:"Higher cost for non-paginated lists to prevent large queries."})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:(0,r.jsx)(i.code,{children:"API_GRAPHQL_MUTATION_BASE_COST"})}),(0,r.jsx)(i.td,{children:"Base cost for mutations, since they modify data."})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:(0,r.jsx)(i.code,{children:"API_GRAPHQL_SUBSCRIPTION_BASE_COST"})}),(0,r.jsx)(i.td,{children:"Base cost for subscriptions, due to continuous real-time updates."})]})]})]}),"\n",(0,r.jsx)(i.p,{children:"These variables define how query complexity is calculated and ensure fair API usage."}),"\n",(0,r.jsx)(i.h2,{id:"example-queries",children:"Example Queries"}),"\n",(0,r.jsx)(i.h3,{id:"simple-query",children:"Simple Query"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-graphql",children:'query GetUserProfile {\n  user(id: "123") {\n    id\n    name\n    email\n  }\n}\n'})}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Complexity Calculation:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"user"}),": 1 (object field)"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"id"}),": 0 (scalar field)"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"name"}),": 0 (scalar field)"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"email"}),": 0 (scalar field)"]}),"\n",(0,r.jsx)(i.li,{children:(0,r.jsx)(i.strong,{children:"Total Cost: 1"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"nested-query",children:"Nested Query"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-graphql",children:'query GetUserWithCreator {\n  user(id: "123") {\n    id\n    name\n    creator {\n      id\n      name\n    }\n  }\n}\n'})}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Complexity Calculation:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"user"}),": 1 (object field)"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"id"}),": 0 (scalar field)"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"name"}),": 0 (scalar field)"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"creator"}),": 1 (object field)"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"id"})," (inside creator): 0 (scalar field)"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"name"})," (inside creator): 0 (scalar field)"]}),"\n",(0,r.jsx)(i.li,{children:(0,r.jsx)(i.strong,{children:"Total Cost: 1 + 1 = 2"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"relay-based-nested-query",children:"Relay-Based Nested Query"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-graphql",children:'query GetUserWithOrganizations {\n  signIn(input: { emailAddress: "testsuperadmin@example.com", password: "Pass@123" }) {\n    user {\n      id\n      organizationsWhereMember(first: 5, after: null) {\n        pageInfo {\n          hasPreviousPage\n        }\n        edges {\n          cursor\n          node {\n            id\n          }\n        }\n      }\n    }\n    authenticationToken\n  }\n}\n'})}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Complexity Calculation:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"user"}),": 1 (object field)"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"organizationsWhereMember"}),": 1 (list field)"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"edges"}),": 2 (object field)"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"edges"})," fetched 5 times: 5 * 2 = 10"]}),"\n",(0,r.jsx)(i.li,{children:(0,r.jsx)(i.strong,{children:"Total Cost: 1 + 1 + 10 = 12"})}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"pageInfo"})," is treated as a scalar and does not add to the cost because it is calculated every time regardless of whether the user requests it or not. Since it is an inherent part of pagination logic, including it in cost calculation would unfairly penalize users for standard pagination behavior."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"simple-mutation",children:"Simple Mutation"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-graphql",children:'mutation CreatePost {\n  createPost(input: { title: "GraphQL Rate Limiting", content: "Understanding cost-based rate limiting." }) {\n    id\n    title\n    content\n  }\n}\n'})}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Complexity Calculation:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"createPost"}),": ",(0,r.jsx)(i.strong,{children:"10"})," (mutation base cost)"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"id"}),": 0 (scalar field)"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"title"}),": 0 (scalar field)"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"content"}),": 0 (scalar field)"]}),"\n",(0,r.jsx)(i.li,{children:(0,r.jsx)(i.strong,{children:"Total Cost: 10"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"references",children:"References"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:(0,r.jsx)(i.a,{href:"https://docs.github.com/en/graphql/overview/rate-limits-and-node-limits-for-the-graphql-api",children:"GitHub GraphQL API Rate Limits"})}),"\n",(0,r.jsx)(i.li,{children:(0,r.jsx)(i.a,{href:"https://shopify.engineering/rate-limiting-graphql-apis-calculating-query-complexity",children:"Shopify Engineering - Rate Limiting GraphQL APIs"})}),"\n",(0,r.jsx)(i.li,{children:(0,r.jsx)(i.a,{href:"https://graphql-api-gateway.com/graphql-api-gateway-patterns/complexity-based-rate-limiting-quotas",children:"GraphQL API Gateway Patterns - Complexity-Based Rate Limiting"})}),"\n",(0,r.jsx)(i.li,{children:(0,r.jsx)(i.a,{href:"https://medium.com/@xuorig/a-guide-to-graphql-rate-limiting-security-e62a86ef8114",children:"A Guide to GraphQL Rate Limiting & Security"})}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,l.R)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},55288:(e,i,n)=>{n.d(i,{R:()=>t,x:()=>a});var s=n(30758);const r={},l=s.createContext(r);function t(e){const i=s.useContext(l);return s.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function a(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),s.createElement(l.Provider,{value:i},e.children)}}}]);