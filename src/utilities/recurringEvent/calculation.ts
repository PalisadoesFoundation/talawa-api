import type { z } from "zod";
import type { recurrenceRulesTable } from "~/src/drizzle/tables/recurrenceRules";
import type { recurrenceInputSchema } from "~/src/graphql/inputs/RecurrenceInput";

/**
 * Calculates the completion date of a recurrence that is defined by a `count`.
 * This function is used internally by `normalizeRecurrenceRule` to convert a count-based
 * recurrence into an end-date-based one. It can also be used for estimating the
 * duration of a recurring event.
 *
 * @param startDate - The start date of the recurrence.
 * @param count - The total number of occurrences.
 * @param frequency - The frequency of the recurrence (e.g., "DAILY", "WEEKLY").
 * @param interval - The interval between occurrences (default is 1).
 * @returns - The calculated date of the final occurrence.
 */
export function calculateCompletionDateFromCount(
	startDate: Date,
	count: number,
	frequency: string,
	interval = 1,
): Date {
	const completionDate = new Date(startDate);

	switch (frequency) {
		case "DAILY":
			completionDate.setDate(completionDate.getDate() + (count - 1) * interval);
			break;
		case "WEEKLY":
			completionDate.setDate(
				completionDate.getDate() + (count - 1) * interval * 7,
			);
			break;
		case "MONTHLY":
			completionDate.setMonth(
				completionDate.getMonth() + (count - 1) * interval,
			);
			break;
		case "YEARLY":
			completionDate.setFullYear(
				completionDate.getFullYear() + (count - 1) * interval,
			);
			break;
		default:
			// Default to daily if frequency is unknown
			completionDate.setDate(completionDate.getDate() + (count - 1) * interval);
	}

	return completionDate;
}

/**
 * Estimates the total number of instances that will be generated by a recurrence rule.
 * If the rule is based on a `count`, it returns the count. If it's based on an `endDate`,
 * it calculates the number of occurrences. For never-ending events, it estimates the
 * number of instances over a specified time window (default is 12 months).
 *
 * @param rule - The recurrence rule to estimate.
 * @param estimationWindowMonths - The number of months to use for estimation if the event is never-ending.
 * @returns - The estimated total number of instances.
 */
export function estimateInstanceCount(
	rule: typeof recurrenceRulesTable.$inferSelect,
	estimationWindowMonths = 12,
): number {
	// If has explicit count, use it
	if (rule.count) return rule.count;

	// If has end date, calculate based on duration
	if (rule.recurrenceEndDate) {
		const daysDiff = Math.ceil(
			(rule.recurrenceEndDate.getTime() - rule.recurrenceStartDate.getTime()) /
				(1000 * 60 * 60 * 24),
		);
		const interval = rule.interval || 1;

		switch (rule.frequency) {
			case "DAILY":
				return Math.ceil(daysDiff / interval) + 1;
			case "WEEKLY":
				return Math.ceil(daysDiff / (7 * interval));
			case "MONTHLY":
				return Math.ceil(daysDiff / (30 * interval));
			case "YEARLY":
				return Math.ceil(daysDiff / (365 * interval));
			default:
				return Math.ceil(daysDiff / interval);
		}
	}

	// Never-ending: estimate based on window
	const interval = rule.interval || 1;
	const daysInWindow = estimationWindowMonths * 30;

	switch (rule.frequency) {
		case "DAILY":
			return Math.ceil(daysInWindow / interval);
		case "WEEKLY":
			return Math.ceil(daysInWindow / (7 * interval));
		case "MONTHLY":
			return Math.ceil(estimationWindowMonths / interval);
		case "YEARLY":
			return Math.ceil(estimationWindowMonths / 12 / interval);
		default:
			return Math.ceil(daysInWindow / interval);
	}
}

/**
 * Calculates the estimated number of instances per month for a given frequency and interval.
 * This is useful for resource planning, performance estimations, and other calculations
 * where an average monthly occurrence rate is needed.
 *
 * @param frequency - The frequency of the recurrence (e.g., "DAILY", "WEEKLY").
 * @param interval - The interval between occurrences (default is 1).
 * @returns - The average number of instances expected in a month.
 */
export function calculateInstancesPerMonth(
	frequency: string,
	interval = 1,
): number {
	// Validate interval parameter
	if (!Number.isFinite(interval) || interval <= 0) {
		throw new RangeError("interval must be a positive number");
	}

	switch (frequency) {
		case "DAILY":
			return 30 / interval; // ~30 days per month
		case "WEEKLY":
			return 4.33 / interval; // ~4.33 weeks per month
		case "MONTHLY":
			return 1 / interval;
		case "YEARLY":
			return 1 / (12 * interval); // 1/12 of a year per month
		default:
			return 30 / interval; // Default to daily
	}
}

/**
 * Normalizes a recurrence rule by converting a `count`-based rule to an `endDate`-based one.
 * This allows for uniform processing of events that have a defined end, whether specified
 * by a count of occurrences or a specific end date. If the rule is already `endDate`-based
 * or is infinite (never-ending), it is returned unchanged.
 *
 * @param rule - The recurrence rule from the database.
 * @returns - A normalized recurrence rule, where `count` has been converted to `recurrenceEndDate`.
 */
export function normalizeRecurrenceRule(
	rule: typeof recurrenceRulesTable.$inferSelect,
): typeof recurrenceRulesTable.$inferSelect {
	// If rule has count but no end date, convert count to end date
	if (rule.count && !rule.recurrenceEndDate) {
		// Validate inputs before calculation
		// 1. Validate count is a positive integer
		if (!Number.isInteger(rule.count) || rule.count <= 0) {
			throw new Error(
				`Invalid recurrence count: ${rule.count}. Count must be a positive integer.`,
			);
		}

		// 2. Validate and compute interval
		const interval = rule.interval ?? 1;
		if (!Number.isInteger(interval) || interval <= 0) {
			throw new Error(
				`Invalid recurrence interval: ${interval}. Interval must be a positive integer.`,
			);
		}

		// 3. Validate recurrenceStartDate is a valid Date object
		if (
			!(rule.recurrenceStartDate instanceof Date) ||
			Number.isNaN(rule.recurrenceStartDate.getTime())
		) {
			throw new Error(
				`Invalid recurrence start date: ${rule.recurrenceStartDate}. Must be a valid Date object.`,
			);
		}

		const calculatedEndDate = calculateCompletionDateFromCount(
			rule.recurrenceStartDate,
			rule.count,
			rule.frequency,
			interval,
		);

		return {
			...rule,
			recurrenceEndDate: calculatedEndDate,
		};
	}

	// Return rule as-is if it already has end date or is never-ending
	return rule;
}

/**
 * Applies calendar-style override logic for recurring event updates.
 * This function implements the following rules:
 * 1. If startAt is provided and byDay is not specified in recurrence,
 *    derive byDay from the new startAt day of week
 * 2. If byDay is explicitly provided in recurrence, use it as-is
 * 3. For monthly/yearly events, similar logic applies to byMonthDay/byMonth
 *
 * @param newStartAt - The new start time for the event (if provided)
 * @param originalRecurrence - The original recurrence rule from the database
 * @param inputRecurrence - The recurrence input from the user (if provided)
 * @returns - The updated recurrence configuration with proper overrides applied
 */
export function applyRecurrenceOverrides(
	newStartAt: Date | undefined,
	originalRecurrence: Pick<
		typeof recurrenceRulesTable.$inferSelect,
		| "frequency"
		| "interval"
		| "recurrenceEndDate"
		| "count"
		| "byDay"
		| "byMonth"
		| "byMonthDay"
	>,
	inputRecurrence?: z.infer<typeof recurrenceInputSchema>,
): z.infer<typeof recurrenceInputSchema> {
	// Start with the provided recurrence input or create from original
	const recurrence = inputRecurrence ?? {
		frequency: originalRecurrence.frequency,
		interval: originalRecurrence.interval,
		endDate: originalRecurrence.recurrenceEndDate ?? undefined,
		count: originalRecurrence.count ?? undefined,
		never: !originalRecurrence.recurrenceEndDate && !originalRecurrence.count,
		byDay: originalRecurrence.byDay ?? undefined,
		byMonth: originalRecurrence.byMonth ?? undefined,
		byMonthDay: originalRecurrence.byMonthDay ?? undefined,
	};

	// Override logic: startAt always wins if provided, otherwise use byDay
	if (newStartAt) {
		// If startAt is provided, derive byDay from it regardless of input byDay
		const dayMap = ["SU", "MO", "TU", "WE", "TH", "FR", "SA"];
		const dayIndex = newStartAt.getDay();

		if (dayIndex < 0 || dayIndex >= dayMap.length) {
			// This case should ideally not happen with valid Date objects
			throw new Error("Invalid day of week derived from startAt");
		}
		const newDayOfWeek = dayMap[dayIndex];

		if (newDayOfWeek) {
			if (recurrence.frequency === "WEEKLY") {
				// For weekly events, only override byDay if not explicitly provided in input
				if (!inputRecurrence?.byDay) {
					recurrence.byDay = [newDayOfWeek];
				}
			} else if (recurrence.frequency === "MONTHLY") {
				// For monthly events, if byDay was previously set, update it
				// Also set it if no byDay was originally set but we have a new start day
				if (
					!inputRecurrence?.byDay &&
					((originalRecurrence.byDay && originalRecurrence.byDay.length > 0) ||
						!originalRecurrence.byMonthDay)
				) {
					recurrence.byDay = [newDayOfWeek];
				}
			}
		}
	} else if (inputRecurrence?.byDay) {
		// If startAt is not provided but byDay is, use byDay
		recurrence.byDay = inputRecurrence.byDay;
	}

	// For monthly events, handle byMonthDay override logic
	if (
		newStartAt &&
		!inputRecurrence?.byMonthDay &&
		recurrence.frequency === "MONTHLY"
	) {
		// If byMonthDay was previously set and no new byMonthDay provided, update it
		if (
			originalRecurrence.byMonthDay &&
			originalRecurrence.byMonthDay.length > 0
		) {
			recurrence.byMonthDay = [newStartAt.getDate()];
		}
	}

	// If byMonthDay is explicitly provided in input, use it
	if (inputRecurrence?.byMonthDay) {
		recurrence.byMonthDay = inputRecurrence.byMonthDay;
	}

	// For yearly events, handle byMonth override logic
	if (
		newStartAt &&
		!inputRecurrence?.byMonth &&
		recurrence.frequency === "YEARLY"
	) {
		// If byMonth was previously set and no new byMonth provided, update it
		if (originalRecurrence.byMonth && originalRecurrence.byMonth.length > 0) {
			recurrence.byMonth = [newStartAt.getMonth() + 1]; // JavaScript months are 0-indexed
		}
	}

	// If byMonth is explicitly provided in input, use it
	if (inputRecurrence?.byMonth) {
		recurrence.byMonth = inputRecurrence.byMonth;
	}

	return recurrence;
}
