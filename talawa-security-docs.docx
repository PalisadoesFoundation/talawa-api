Talawa Security Improvements - 2025

This is a universally editable document. Any part of this is subject to change by the Talawa community and editing by them is encouraged to get to a suitable outcome.

Please do not abuse this privilege and be respectful of others’ changes and suggestions.

Introduction
mTLS Certified Request with reverse Proxy
Reverse Proxy Placement in Talawa Deployment
Docker Key Benefits
Security Considerations
Implementation Strategy
Potential Drawbacks
Token Rotation
Security Measures
mTLS (Mutual TLS)
IP Whitelisting
RBAC (Role-Based Access Control)
End to End Encryption
Specific Improvements to be Implemented
mTLS Certified Request with Reverse Proxy
Reverse Proxy Placement in Talawa Deployment
Token Rotation Strategy
Session Token (Stored in HTTP-Only Cookie)
Main Token (JWT for API Communication)
Security Measures
mTLS (Mutual TLS)
IP Whitelisting
RBAC (Role-Based Access Control)
End-to-End Encryption
Implementation Plan for Talawa Security Improvements
Overview
Phase 1: Foundational Security
Phase 2: Advanced Security Enhancements
Actionable Steps & IPhase 1: Foundational Securityssues to Be Created

Introduction

We discovered many issues when trying to launch our demo site at https://demo.talawa.io/. 

Many errors were due to all contributors testing the apps on localhost. These included:

XSS errors because the API and Admin docker instances were running on separate IP addresses
The Admin web app could be directed to get GraphQL queries from localhost, if the app’s .env file was configured to contact the API on localhost.

This document outlines potential rectification steps.

The suggestions below are roughly based on this architecture diagram. 



mTLS Certified Request with reverse Proxy

To enhance security, all requests will be mTLS signed via HTTPS. The webserver will use this as the basis of validation. This would apply to both  web app and mobile app clients. This ensures that the API only handles requests from a trusted source. By enforcing this architecture, we prevent unauthorized access, reduce attack vectors, and centralize authentication and security policies in one place.

Only our proxy can request api to run queries, signed requests are validated by proxy, proxy is rate limited and ip trying brute force will be blocked by proxy.

Suggestion: If we are refactoring on this scale, If convenient we should use nginx since apache is similar but is old tech, also a new application coming into market would be more eye catching if modern technologies are used. If we can take a look into our codebase and check if it is not that hard at this moment we can switch.
We are not using php or .htaccess ( not very sure) so relying on apache is not a boundation right now.

Reverse Proxy Placement in Talawa Deployment
There are two possible approaches to this:
    • Self-Hosted & VM-Based Deployment (Standalone Nginx Outside Docker)
    • Docker-Based Deployment (Nginx Inside Docker)
We are a volunteer organization, therefore we have chosen the Docker based approach as the easiest for long term maintainability.
Docker Key Benefits
    1. Simplified Deployment and Maintenance
        a. Deploying Nginx within Docker means all services can be managed through a single Docker Compose or Kubernetes configuration.
        b. Easier to update and scale since all dependencies are contained within Docker images.
    2. Fully Portable & Compatible with Containerized Workflows
        a. Ideal for local development, CI/CD pipelines, and microservices architectures.
        b. Ensures consistent configuration across different environments, reducing discrepancies between staging and production.
    3. Integrated Load Balancing & Scaling
        a. Nginx within Docker can be horizontally scaled along with API containers.
        b. If required, it can be linked with Docker Swarm or Kubernetes for automated failover handling.
Security Considerations
    1. Increased Exposure to Attacks
        a. Since Nginx is inside Docker, it is exposed to external traffic.
        b. If Nginx is compromised, the attacker gains access to the containerized environment.
    2. Potential Risk to the Entire Server
        a. In rare cases, a container breakout vulnerability could allow an attacker to escalate privileges to the host system.
        b. Mitigation: Run Nginx with the least privileges and use AppArmor, SELinux, or seccomp profiles.
    3. Firewalling Becomes More Complex
        a. The host-level firewall cannot directly block container-to-container traffic.
        b. Mitigation: Enforce Docker network policies to restrict API container access.
Implementation Strategy
    1. Nginx runs as a container in the same Docker Compose network as the API.
    2. Firewall rules inside Docker ensure API is only accessible via Nginx.
    3. Environment variables and configuration management tools (e.g., Consul, Vault) handle TLS certificates and secrets securely.
Potential Drawbacks
    1. Slightly lower security compared to the standalone Nginx approach.
    2. If the Nginx container is compromised, there is a risk to other containers.
Token Rotation
For effective session management and secure communication, we implement a two-token strategy:

    1. Session Token (Stored in HTTP-Only Cookie)
        a. We need to deploy backend and frontend on the same domain to ensure our cookies are  handled using backend only and modifications cannot be made by client..
    2. The session token is used only for web clients and is stored in an HTTP-only cookie, making it inaccessible to JavaScript. This prevents Cross-Site Scripting (XSS) attacks. The session token has a short lifespan (15-30 minutes) and is used to track user sessions without requiring frequent logins.
        a. To hide RBAC from users, we should use JWE instead of JWT, data in JWE cannot be seen as we can do with JWT, but if we are good with users being able to see roles, then JWE is not needed as it is slower than JWT.
    3. Main Token (JWT for API Communication)
        a. We would need to rotate the main token but on longer spans.
        b. The Admin Server generates a short-lived JWT token to communicate securely with the API. This token includes user roles (RBAC), timestamps (iat & exp), and claims to ensure proper access control. Since it expires quickly, it mitigates replay attacks by preventing the reuse of old tokens.

This approach balances security (preventing attacks) and usability (minimizing login friction).


Security Measures
The following security improvements are proposed
mTLS (Mutual TLS)
To secure communication between the Admin Server and API, we enforce mTLS (Mutual TLS). This ensures that both the server and API authenticate each other using certificates, preventing man-in-the-middle attacks.
IP Whitelisting
IP whitelisting could be used to restrict server to server endpoints to reduce the risk of  unauthorized access.

IP whitelisting is practically impossible for app users since app does not carry fix ip as web apps, they carry ip of mobile device they are used on, we cannot validate requests based on IP, instead we will need to use OAuth2.0

Conclusion: IP whitelisting can be used wherever necessary like proxy to api or api to dbi, but not client to proxy either for web or app.
RBAC (Role-Based Access Control)
Instead of assigning permissions individually, users are categorized into roles (such as admin, moderator, or user). These roles determine what actions they can perform. The Admin Server issues JWT tokens with role-based permissions, ensuring that API endpoints are only accessible to authorized users. This prevents privilege escalation attacks and simplifies permission management.
End to End Encryption
Sending raw data such as messages within organizations could be sniffed easily and leaked, we should use any encryption method to ensure data sent over the internet cannot be read. Frontend will encrypt data using our key, only our backend can read and store it.

Specific Improvements to be Implemented
These are the improvements to be implemented.
mTLS Certified Request with Reverse Proxy
Steps for Implementation:
    1. Setup Nginx with mTLS
        ◦ Configure Nginx to enforce Mutual TLS (mTLS) authentication.
        ◦ Issue client certificates for the web and mobile apps.
        ◦ Enforce HTTPS for all API communications.
    2. Proxy Request Validation
        ◦ Ensure only the proxy can send requests to the API.
        ◦ Implement rate limiting and IP blocking for repeated failed attempts.
    3. Technology Upgrade
        ◦ Evaluate the feasibility of replacing Apache with Nginx for better performance and modern security features.
        ◦ Ensure minimal refactoring is needed for compatibility.

Reverse Proxy Placement in Talawa Deployment
Implementation Steps:
    1. Integrate Nginx in Docker Compose setup.
    2. Implement Docker security policies:
        a. Use AppArmor, SELinux, or seccomp profiles.
        b. Restrict inter-container traffic with network policies.
    3. Ensure API is accessible only via Nginx.
    4. Manage TLS certificates securely using environment variables or tools like Vault.
    5. Enable auto-scaling and load balancing.

Token Rotation Strategy
We will use a 2 part token rotation strategy:

    1. Tokens will be generated by API, since API has connection with database so it can assign correct roles to users.
    2. To prevent brute force attacks on id/password, nginx will rate-limit authentication requests.
Session Token (Stored in HTTP-Only Cookie)
To prevent token sniffing or decoding, we keep changing the token on short spans, preventing attackers from getting sufficient time to reuse or modify old tokens.
Implementation Steps:
    1. Ensure frontend and backend are on the same domain.
    2. Set up HTTP-only, secure cookies for session tokens.
    3. Enforce short token expiration (15-30 minutes).
    4. Decide on JWE vs. JWT for RBAC concealment.
Main Token (JWT for API Communication)
As a session token expires after a certain period, to re-issue a new session token without requiring the user to sign in again, we need to verify user authentication by sending this main token as verification.
Implementation Steps:
    1. Generate short-lived JWT tokens with RBAC roles.
    2. Implement token rotation at periodic intervals.
    3. Prevent replay attacks using issued-at (iat) and expiration (exp) timestamps.

Security Measures
There will be a variety of security approaches
mTLS (Mutual TLS)
To make sure that only requests sent by our web/app client can pass through nginx, we can self-sign our requests for identification, from a long time SSL was used for signing requests, TLS is then introduced with better security than SSL, mTLS or mutual TLS allows us to mutually sign the requests so that both client and nginx can verify each other. This prevents attackers from bypassing nginx, also they cannot become man-in-the-middle or manipulate our clients giving a false impression to them such that they are  connected to the server while the attacker is sending data to the client on its own. This makes mutual signing really important.
Implementation Steps:
    1. Issue TLS certificates for both the API and Admin Server.
    2. Configure Nginx and API to enforce mTLS validation.
    3. Deny requests from unauthenticated clients.
IP Whitelisting
IP whitelisting ensures that only requests from pre-approved IP addresses can access critical backend services.
Benefits Over Other Approaches:
    1. Lower attack surface: Only known IPs can communicate with the API.
    2. Prevents unauthorized access: Eliminates the risk of attackers using stolen credentials from unapproved locations.
    3. No reliance on user credentials: Prevents attacks where authentication tokens are compromised.
Implementation Steps:
    1. Whitelist known IPs for Proxy-to-API communication
    2. Whitelist know IPs for API-to-Database communication
    3. For mobile clients, implement OAuth 2.0 instead of IP-based restrictions for more flexibility.

RBAC (Role-Based Access Control)
RBAC ensures that users can only access data and perform actions based on their assigned roles.
Benefits Over Other Approaches:
    1. Granular control: Limits access based on user roles (e.g., Admin, User, Moderator).
    2. Reduced attack impact: Even if credentials are compromised, attackers have restricted permissions.
    3. Scalability: Easily extendable to support custom roles.
Implementation Steps:
    1. Define roles and permissions for users.
    2. Ensure JWT tokens include RBAC claims for validation.
    3. Restrict API access based on roles, enforcing policies at the server level.
End-to-End Encryption

E2EE ensures that sensitive messages and files are encrypted before transmission and only decrypted by the recipient. Here is a comparison of encryption methods we evaluated:
ChaCha20-Poly1305
    1. Use Case: Real-time messaging
    2. Security Level: Medium
    3. Speed: Fast
    4. Best For: Chat & communication
AES-256-GCM
    5. Use Case: File encryption & JSON data
    6. Security Level: High
    7. Speed: Slower
    8. Best For: Protecting sensitive document
Since organization chat involves frequent messages, ChaCha20 is preferred due to its high speed. However, for files, AES-256-GCM is better due to its stronger security despite being slightly slower.
Implementation Steps:
    1. Implement client-side encryption for sensitive data before transmission.
    2. Ensure the backend securely decrypts and processes encrypted data.
    3. Use:
        a. AES-256-GCM for file handling and structured data.
        b. ChaCha20-Poly1305 for messaging (since it is faster than RSA for real-time communication).
Implementation Plan for Talawa Security Improvements
This is the proposed implementation plan
Overview
The security improvements will be implemented in two phases:
    1. Phase 1: Establishes a foundational security model with authentication, authorization, and basic protective measures.
    2. Phase 2: Enhances security with encryption, restricted access, and optimized performance.

Phase 1: Foundational Security
This phase ensures a smooth and secure rollout with minimal disruption.
Key Implementations:

    1. Admin Server as a Gateway
        a. Route all web requests through the Admin Server. (Done)
            i. https://github.com/PalisadoesFoundation/talawa-admin/issues/3755 
            ii. One possible approach
                1. https://docs.google.com/document/d/1465DpM1G1eNqJKjBjIvyvMjbnL3LcfiYPZw9fgait_Q/edit?tab=t.0 
                2. https://docs.google.com/document/d/18nFPcaui_jEdYUq_mJ06mcJos7rglwFpG_irggeTj6Y/edit?tab=t.0 
            iii. Done
                1. https://github.com/PalisadoesFoundation/talawa-admin/issues/4697 
        b. Secure the connection with SSL and signed certificates. (Done)
            i. Requires public SSL certificates. We are already using this in our test and demo websites.
        c. Validate API requests by checking if they are signed by the Admin Server. This includes refactored authentication using REST endpoints, not GraphQL (TBD)
            i. https://github.com/PalisadoesFoundation/talawa-api/issues/3305 
    2. Authentication & Authorization
        a. HTTP-Only Cookies for web clients to protect session tokens from XSS attacks. (In Progress)
            i. https://github.com/PalisadoesFoundation/talawa-api/issues/3290 
        b. Short-Lived JWTs to secure communication between the Admin Server and API.
            i. https://github.com/PalisadoesFoundation/talawa-admin/issues/4971 
    3. API Security & Performance
        a. Implement Rate Limiting to prevent abuse and DDoS attacks. (Done)
            i. https://github.com/PalisadoesFoundation/talawa-api/issues/3309
            ii. https://docs.google.com/document/d/152l1rGiwLyLHjJwj0PQLzv2RLdS19ufE_3r3SrjZ8wg/edit?usp=drivesdk 
        b. Apply Input Sanitization to prevent injection attacks.  (In Progress)
            i. https://github.com/PalisadoesFoundation/talawa-api/issues/3372 
This phase provides a strong security foundation with minimal overhead.

Phase 2: Advanced Security Enhancements
For end users and systems requiring stricter security, additional measures will be introduced.
Key Implementations:

    1. Secure API Communication
    a. Implement some sort of easily implementable encryption over the wire methodology for use with a TLS tunnel that the end user may implement. For example, communication between the API and Admin apps in test.talawa.io uses communication with https://api-test.talawa.io however we need an encryption methodology what will work with or without the HTTPS wrapper.
        i. One option is Mutual TLS (mTLS) for encrypted and authenticated communication between the Admin Server and API, however it may not be suitable for non-profit organizations without competent IT teams.
    2. RBAC -  (ROLE BASED ACCESS CONTROL)
        a. Authenticate users and apply RBAC (Role-Based Access Control).
        b. Execute GraphQL queries and return encrypted responses.
    3. Access Control Enhancements
        a. Apply IP Whitelisting to restrict API access to the Admin Server’s IP.
    4. Performance Optimizations  (In Progress)
        a. Enable TCP Connection Pooling to reduce API load and improve request handling efficiency.
            i. https://github.com/PalisadoesFoundation/talawa-admin/issues/4972 
    5. Mobile Client Security
        a. Implement OAuth for authentication and secure token storage for mobile clients.

Actionable Steps & Issues to Be Created
    1. Set up Admin Server as a Gateway (Phase 1)
    2. Implement request validation with signed tokens (Phase 1)
        a. This must comply with our authentication approach: https://docs-api.talawa.io/docs/developer-resources/introduction/#authentication 
    3. Add HTTP-Only Cookies for web clients (Phase 1)
    4. Configure short-lived JWTs for secure API communication (Phase 1)
        a. This must comply with our authentication approach: https://docs-api.talawa.io/docs/developer-resources/introduction/#authentication 
    5. Apply rate limiting to API endpoints (Phase 1)
    6. Sanitize all API inputs to prevent attacks (Phase 1)
    7. Implement mTLS for API communication (Phase 2)
    8. Restrict API access via IP whitelisting (Phase 2)
    9. Optimize API performance with TCP connection pooling (Phase 2)
    10. Integrate OAuth and secure storage for mobile clients (Phase 2)

